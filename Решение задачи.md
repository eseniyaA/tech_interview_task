## Проблемы исходной версии

|  | Проблема | Описание | Критичность | Решение |
| :---- | :---- | :---- | :---- | :---- |
| 1\. | Отсутствует обработка ошибок | Автотесты пишутся для отлова возможных ошибок, но без обработки ошибок тест может продолжить выполнение при наличии серьёзных проблем. Это может скрыть реальную причину сбоя и затруднить отладку | Высокая | Обернуть запросы к API и вызовы функций конструкцией try catch. И добавить проброс ошибок для остановки теста при критических сбоях |
| 2\. | Токен передается прямо в коде | Хранение токенов в коде — это плохая практика с точки зрения безопасности, так как это может привести к их утечке. Токены должны быть спрятаны в переменные окружения. | Высокая | Перенести токен в переменные окружения |
| 3\. | Тестовые данные выбираются на рандом | В тесте случайным образом выбирается одна из пород. Это может затруднить отладку и сделать тесты непредсказуемыми, в случае когда для разных пород результат запуска теста будет разным | Высокая | Сделать тест параметризированным, чтобы тестировать все возможные конфигурации последовательно, а не случайным образом |
| 4\. | Тест падает на этапе загрузки изображения | Изображения в тесте не загружаются на Я.Диск, тк нет вызова функции uploadPhotosToYd | Высокая | Добавить вызов функции uploadPhotosToYd |
| 5\. | В тесте запрашиваются две картинки вместо одной | В тесте делается два запроса на получение изображений, что не соответствует требованиям               | Средняя | Убрать избыточный вызов функции для получения второго изображения |
| 6\. | Нагромождение промисами | Использование промисов через `.then()` создаёт вложенности и ухудшает читаемость кода  | Средняя | Можно использовать async/await для последовательного и более читабельного выполнения асинхронных операций |
| 7\. | Нет проверки на корректность загруженных файлов | Тест проверяет факт создания файла, но не проверяет его содержимое. Это может привести к ложноположительным результатам, если файл некорректен или повреждён | Средняя | Можно добавить проверку на количество загруженных файлов и проверку на соответствие загруженных файлов |
| 8\. | Переменные `allUrls` и `allSubBreeds` объявлены, но нигде не используются. | Переменные `allUrls` и `allSubBreeds` объявлены, но не применяются в коде, что создаёт ненужное нагромождение. Это ухудшает читабельность и может привести к путанице. | Низкая | Либо использовать переменные по назначению, либо удалить их, если они не нужны |
| 9\.  | Нет явного вывода результата теста | В исходной версии успешный тест завершится выводом строки с сообщением `File found`, но это не даёт чёткого понимания о результате всего теста  | Низкая | Добавить явный итог с выводом в консоль текста Test passed/Test failed |
| 10\. | Названия некоторых функций не отражают их назначения | Функции `u` и `t` используют неинформативные названия, что затрудняет понимание их цели | Низкая | Переименовать функции, чтобы их названия отражали их функциональность |

## Что я сделала в своей версии теста: 

* **Заменила промисы на async/await.** 

  **Почему:** 

  	Асинхронные вызовы с async/await лучше подходят для тестов, так как они делают код более последовательным и синхронным на вид, что снижает вероятность непредвиденных ошибок. К тому же, async/await улучшает читабельность по сравнению с вложенными .then() блоками, делая код проще для понимания и сопровождения.

* **Добавила обработку исключений блоком try..catch**

  **Почему:** 

  	Обработка исключений полезна не только для улучшения отладки, но и обеспечит стабильность теста. С этой конструкцией будет легче понять, что пошло не так, и логично завершить выполнение теста на критически важных шагах таких как, например, создание папки и получение файла для загрузки

* **Вынесла базовые урлы в отдельные константы**

  **Почему:** 

  	Такое решение обусловлено несколькими причинами:  
  		1\. Читаемость кода \- легче понять, к какому API выполняются запросы.

  2\. Поддерживаемость \- упрощает переключение между окружениями без изменения остального кода.

  3\. Переиспользование \- упрощает сопровождение кода и снижает дублирование.

  4\. Гибкость \- если URL изменится, его обновление потребует минимум усилий и сведёт к минимуму риск ошибки.

* **Порефакторила названия переменных**

  **Почему:**

  	Четкие и говорящие названия переменных улучшают понимание кода и его сопровождение. Переименование переменных и функций с коротких, таких как t и u, на более осмысленные помогает легче ориентироваться в коде

* **Спрятала токен в переменную окружения**

  **Почему:**

  	Хранение токенов в коде \- плохая практика с точки зрения безопасности. Даже на тестовом окружении лучше не хранить секретные данные в исходном коде, чтобы предотвратить возможные риски.

* **Убрала избыточный запрос второй картинки в функции fetchUrls**

  **Почему:**

  	В описании функции написано “находит ОДНУ случайную картинку и загружает её”. Тест не соответствовал требованиям, поэтому я удалила повторный вызов функции

* **Убрала рандомный выбор тестовой породы и сделала условную параметризацию**

  **Почему:** 

  	Использовать разнообразные тестовые данные в тестах хорошо, но лучше это делать не через рандом. Рандомайзер в данном случае может затруднить отладку теста, если вдруг тест падает на конкретной породе. Также с рандомайзером можно пропустить ошибку, которая проявлялась бы только с конкретной породой, только потому что тест запустился с той породой, с которой все отлично работает.   
  	Если бы мы использовали тестовый фреймворк, то можно было бы пойти через конструкцию each и сделать параметризированный тест, но так как тут у нас чистый TS, я использовала цикл for

* **Доработала функцию загрузки изображений на диск**

  **Почему:**

  	Основная проблема теста заключалась в том, что изображения не загружались на диск. Мы сохраняли их урлы, но никак не использовали. Поэтому я добавила вызов функции uploadPhotosToYd. И так как тест теперь параметризированный, немного доработала создание директории.

* **Убрала глобальные переменные allUrls и allSubBreed**

  **Почему:**

  	С переходом к параметризации эти переменные стало необходимо очищать каждую итерацию, чтобы не допустить смешения данных и некорректных результатов. Но я решила в принципе их убрать, так как глобальные переменные здесь только ухудшают читаемость кода и увеличивают вероятность ошибки. Я немного поменяла функции fetchSubBreeds и fetchUrls, теперь эти переменные используются в своем контексте в местах, где они действительно имеют смысл  
  	